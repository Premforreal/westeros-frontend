# FRONTEND -> Backend API mapping (what frontend expects)

This file was generated by scanning the frontend codebase (components and services) to identify where API calls will be required and the expected response shapes for the mock backend.

Overview of findings
- Current API usage is light: the app uses a local JSON file for property/realm data (`assets/mock-data/properties.json`) via `PropertyService`.
- There is a generated `PingControllerService` (OpenAPI client) which expects `/ping` returning a `PingResponse` model.
- Most other UI flows are currently static (home, property-owner login/dashboard are local), but the following components will need API responses when switched from static/mocks to network-backed data.

Mapping (endpoint → calling file(s) → expected response)

1) GET /api/realms  (or GET /api/properties?group=realms)
   - Called from:
     - `src/app/services/property.service.ts` → `getRealms()`
     - `src/app/home/home.component.ts` (future) for featured realms
   - Current frontend expects a JSON with a top-level `realms` array in the same shape as `assets/mock-data/properties.json`.
   - Example response (partial):
     ```json
     {
       "realms": [
         {
           "id": "the-north",
           "name": "The North",
           "description": "...",
           "image": "https://...",
           "properties": [ /* property objects */ ]
         }
       ]
     }
     ```

   - Realm object shape (used in `Realm` type):
     - `id`, `name`, `description`, `image`, `properties: Property[]`

2) GET /api/properties
   - Called from:
     - `src/app/services/property.service.ts` via `getAllProperties()` indirectly (the service currently flattens `realms` -> properties)
     - Future search or listing pages
   - Expected response: same JSON as `properties.json` (or a root `properties` array). For the mock server it's easiest to return the same document at `/api/properties` or `/api/realms`.

3) GET /api/properties/:id
   - Called from:
     - `src/app/resort-detail/resort-detail.component.ts` (calls `propertyService.getProperty(propertyId)`)
   - Expected response: a `Property` object with fields used by the component:
     - `id`, `name`, `realm`, `shortDescription`, `description`, `rating`, `priceFrom`, `location`, `coordinates`, `mainImage`, `galleryImages`, `features`, `reviews`, `reviewCategories`, `nearbyAttractions`, `policies`
   - The component currently expects `property.galleryImages` and `property.mainImage` to exist and to compute price using `property.priceFrom`.

4) (Optional) GET /api/featured/properties and GET /api/featured/realms
   - Caller: `HomeComponent` and any featured widgets (currently static arrays in `home.component.ts`).
   - If you want to move featured content to the backend, return arrays of `Property` / `Realm` items. For now the frontend will work without these endpoints.

5) POST /api/auth/login  (and POST /api/auth/logout)
   - Caller: Not yet wired to the UI. `AuthService` is currently local-storage based with helper `setMockAuthData()`.
   - Expected response (for login):
     ```json
     {
       "success": true,
       "data": {
         "token": "mock-token",
         "user": { "id": "u_1", "email": "owner@westeros.test", "name": "Owner", "roles": ["PropertyOwner"] }
       }
     }
     ```
   - Property-owner login page (`src/app/property-owner/home/home.component.html`) currently has a static form; attach it later to call this endpoint.

6) GET /api/bookings and POST /api/bookings
   - Caller: Not yet implemented in code. `ResortDetailComponent` has a `bookNow()` method that currently shows an alert; to persist bookings the frontend will need these endpoints.
   - Booking object shape: `id, propertyId, userId, startDate, endDate, totalAmount, status`.

7) GET /api/menu  and GET /api/product-config
   - Caller: `src/app/layouts/navbar/navbar.component.ts` imports `MENU` from local `menu.config.ts` (file replaced at build-time). If you want a dynamic backend-provided menu/product config, the frontend will expect an array of `MenuItem` objects or a `ProductConfig` object similar to `src/product-configurations/product-config.ts`.

8) GET /ping
   - Caller: Generated OpenAPI client `src/services/services/ping-controller.service.ts`.
   - Expected response shape is the `PingResponse` model in `src/services/models/ping-response.ts`:
     ```ts
     export interface PingResponse {
       date?: string;
       greeting?: string;
       headers?: { 'Content-Type'?: string; [key:string]: any };
       url?: string;
     }
     ```
   - For a simple mock backend return a JSON compatible with that interface (e.g., `date` and `greeting`).

Notes / Recommendations for mock server
- Quick wins for the mock server (minimal to satisfy frontend):
  1. Expose `/api/realms` returning the content of `assets/mock-data/properties.json` (shape: { realms: [...] }). This will let `PropertyService.getRealms()` continue to work without code changes.
  2. Expose `/api/properties/:id` returning the specific property extracted from the same JSON (or expose `/api/properties` and filter on the server side).
  3. Implement `/ping` to return the `PingResponse` shape so the generated client works.
  4. Implement `/api/auth/login` with two test users: `owner@westeros.test` (roles: PropertyOwner) and `customer@westeros.test` (roles: User). Return token + user object.

Minimal hardcoded response examples (copy these into mock server handlers)

- GET /api/realms
  - Return the full `assets/mock-data/properties.json` as-is (200): `{ "realms": [...] }`.

- GET /api/properties/:id
  - Return the matching property object (200). Example:
  ```json
  {
    "id": "winterfell",
    "name": "Winterfell Castle Hotel",
    "realm": "The North",
    "shortDescription": "Ancient stronghold...",
    "description": "...",
    "rating": 4.8,
    "priceFrom": 5999,
    "mainImage": "https://...",
    "galleryImages": ["https://..."],
    "features": [...]
  }
  ```

- GET /ping
  - Return: `{ "date": "2025-11-15T12:00:00Z", "greeting": "pong", "url": "/ping" }`

- POST /api/auth/login
  - Request: `{ "email": "owner@westeros.test", "password": "pass" }`
  - Response: `{ "success": true, "data": { "token": "mock-token", "user": { "id": "u_owner1", "email": "owner@westeros.test", "roles": ["PropertyOwner"] } } }`

Files and components scanned (quick list)
- `src/app/resort-detail/resort-detail.component.ts` — expects property data fields listed above
- `src/app/realm-detail/realm-detail.component.ts` — expects realm object with properties array
- `src/app/services/property.service.ts` — currently loads `assets/mock-data/properties.json`
- `src/app/layouts/navbar/navbar.component.ts` — reads `MENU` (local) but can be switched to a backend `GET /api/menu`
- `src/services/services/ping-controller.service.ts` — expects `/ping` with `PingResponse`

Next actions I can take (choose one):
- A) Scaffold a tiny Express mock server under `docs/backend/mock` that implements `/api/realms`, `/api/properties/:id`, `/ping`, `/api/auth/login` and serves the hardcoded responses above. Add an `npm run mock` script.
- B) Create a `docs/backend/mock/db.json` and `routes.json` and show `json-server` setup to serve `/api/*` endpoints mapped to the JSON file.

If you want me to proceed, pick A or B and I will implement and run quick checks.
